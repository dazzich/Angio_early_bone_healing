#include <cstdlib>
#include <iostream>
#include <sstream>
#include <string>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <algorithm>
#include <limits> // Press inter to continue
#include "header.h"

using namespace std;

void Initialize_model(int cell_matrix[N][N], int vessel_x[(N-1)*20][N-1], int vessel_y[(N-1)*20][N-1], int force_dir[N][N], int fibro_number, int& number_vessels_init, int tip_vessel_x [(N-1)*20], int tip_vessel_y [(N-1)*20], int previous_dir [(N-1)*20], int length [(N-1)*20], double X[N*N], double Y[N*N])
{
	fibro_number=0; //fibroblasts counter
	number_vessels_init=0;

//*********************************************************************************************************
//                                      Initialize cell matrix
//*********************************************************************************************************
	cout<<"Initialize cell matrix"<<endl;

	int i,j;

	for (j=0;j<N;j++)
	{
	    for (i=0;i<N;i++)
	    {
	        cell_matrix[j][i]=0;
	        force_dir[j][i]=0;
	    }
	}

	j=0; //bottom boundary
	for (i=0;i<N;i++)
	{
	    cell_matrix[j][i]=1;
	}

	j=N-1; //upper boundary
	for (i=0;i<N;i++)
	{
	    cell_matrix[j][i]=1;
	}

//*********************************************************************************************************
//                     Blocking the area that cells can not migrate to
//*********************************************************************************************************

    for (j=0;j<GAP_Down;j++)  // Bottom Cortical Bones
	{
	    for (i=CL_left;i<CL_right;i++) // Left
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }

	    for (i=CR_left;i<CR_right;i++) //Right
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }
	}
	
	for (j=GAP_Top;j<N;j++)  // Top Cortical Bones
	{
	    for (i=CL_left;i<CL_right;i++) //Left
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }
	    
	    for (i=CR_left;i<CR_right;i++) //Right
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }
	}

	ostringstream s;
    s<<"FEM_0.inp";

    string filename1=s.str();

    ofstream myfile;
    myfile.open(filename1.c_str(),ios::app);

// *************************************  Writing heading of the inp file ***************************************************

    myfile<<"*Heading"<<endl;
    myfile<<"** Job name: Job-1 Model name: Model-1"<<endl;
    myfile<<"** Generated by: Abaqus/CAE 6.9-2"<<endl;
    myfile<<"*Preprint, echo=NO, model=NO, history=NO, contact=NO"<<endl;
    myfile<<"**"<<endl;
    myfile<<"** PARTS"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Node, nset=node_all"<<endl;

// ***********************************************  Writing nodes **********************************************************
    int node;
	node=0;

    for (j=0;j<N;j++)
    {
        for (i=0;i<N;i++)
        {
            node=i+(j*N)+1;
            X[node]=i*0.01; // each element has a side of 0.01 mm = 10 µm
            Y[node]=j*0.01;
            myfile<<node<<", "<<setprecision(15)<<X[node]<<", "<<setprecision(15)<<Y[node]<<endl;
        }
    }
	
	ifstream infile("Control_rigid.txt"); // consider the txt file

    char c = infile.get();

    while  (!infile.eof())
    {
    	myfile << c;
    	c= infile.get();
    }

    cout<<"Cell matrix initialized successfully "<<endl;
    
//*********************************************************************************************************
//                                      Initialize host blood vessels
//*********************************************************************************************************   
    
    cout<<"Initialize blood vessels "<<endl;
    
    int vessel=0;
    float density_vess_bm=0.01; //1% bone marrow
	float density_vess_peri=0.1;//10% periosteum
	int v;
	
	// PERIOSTEUM //
	int n_peri=round(density_vess_peri*SAFE*2);
    //Lower left
	for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+(CL_left-2); 
		j=rand()%SAFE+1;
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;  
    	}
    	tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=7;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel]; 
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
	}
    // Upper left
    for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+(CL_left-2);
		j=rand()%SAFE+(N-1-SAFE);
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;  
    	}
    	tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=3;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
	}
	//Lower right
	for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+CR_right; 
		j=rand()%SAFE+1; 
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;
    	}
    	tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=7;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
    }
    //Upper right
    for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+CR_right;
    	j=rand()%SAFE+(N-1-SAFE);
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;
   		}
		tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=3;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
   		vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1;
    }
    
    // BONE MARROW //
    
    int Marrow_vess_L=0;
	int Marrow_vess_U=0;
	int v_bm=round(density_vess_bm*SAFE*(CR_left-1-CL_right));
	
	// Lower
	while (Marrow_vess_L<v_bm) 
   	{
        i=rand()%(CR_left-CL_right)+CL_right;
        j=rand()%SAFE+1;
        cell_matrix[j][i]=2;
   		tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=7;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
		Marrow_vess_L=Marrow_vess_L+1;	
    }
    // Upper
    while (Marrow_vess_U<v_bm) 
    {
        i=rand()%(CR_left-CL_right)+CL_right;
        j=rand()%SAFE+(N-1-SAFE); 
        cell_matrix[j][i]=2;
   		tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=3;
        length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];    		
    	vessel=vessel+1; 
		Marrow_vess_U=Marrow_vess_U+1;	
    }
    
	
	number_vessels_init=vessel;
    cout<<"Number of vessels: "<<number_vessels_init<<endl;

//*********************************************************************************************************
//                                      Randomly distribute cells in the matrix
//*********************************************************************************************************
    cout<<" Distributing cells in the matrix "<<endl;

    
    int p=0;
	float density_fibro=0.2; //20%
	int c_ext=round(density_fibro*SAFE); 
	// PERIOSTEUM
    // left bottom and up 
    
    i=CL_left-1;
	
	while (p<c_ext) 
	{
		j=rand()%SAFE+1; //Bottom
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;  
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }
    
    p=0;
	
	while (p<c_ext) 
	{
		j=rand()%SAFE+(N-1-SAFE); // Top
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }

	p = 0;

	i = CL_left-2;

	while (p < c_ext)
	{
		j = rand() % SAFE + 1; //Bottom
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;  // put in the upper and lower part of periosteum numbers from 3 to the total n of cells+3
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}

	p = 0;

	while (p < c_ext)
	{
		j = rand() % SAFE + (N-1-SAFE); // Top
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}
    
    // Right bottom and up 
    
    p=0;
    
    i=CR_right; 
	
	while (p<c_ext)
	{
		j=rand()%SAFE+1; //Bottom
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }
    
    p=0;
    
	while (p<c_ext)
	{
		j=rand()%SAFE+(N-1-SAFE); //Top
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }	

	p = 0;

	i = CR_right+1;

	while (p < c_ext)
	{
		j = rand() % SAFE + 1; //Bottom
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}

	p = 0;

	while (p < c_ext)
	{
		j = rand() % SAFE + (N - 1 - SAFE); //Top
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}
    
    // BONE MARROW
	
	int Marrow_cell_L=0;
	int Marrow_cell_U=0;
	int c_bm=round(density_fibro*SAFE*(CR_left-1- CL_right)); //10% of bone marrow until level of disruption
	
	while (Marrow_cell_L<c_bm) // Lower bone marrow
							   
    {
        i=rand()%(CR_left-CL_right)+CL_right;
        j=rand()%SAFE+1;
		if (cell_matrix[j][i]==0)
	    {
	        cell_matrix[j][i]=fibro_number+3;
	        fibro_number=fibro_number+1;
	        Marrow_cell_L=Marrow_cell_L+1;
	    }
    }
    
    while (Marrow_cell_U<c_bm) // Upper bone marrow
    {
        i=rand()%(CR_left-CL_right)+CL_right;
        j=rand()%SAFE+(N-1-SAFE);
		if (cell_matrix[j][i]==0)
	    {
	        cell_matrix[j][i]=fibro_number+3;
	        fibro_number=fibro_number+1;
	        Marrow_cell_U=Marrow_cell_U+1;
	    }
    }	
    


//*********************************************************************************************************
//                                       Dipole direction assignment
//*********************************************************************************************************    
    
	for (j=0;j<N;j++)
	{
	    for (i=0;i<N;i++)
	    {
            if (cell_matrix[j][i]>2) // if there is a fibroblast
            {			
				if (i==0 || i==N-1) //axial dipole at edges of unclamped boundaries
	            {
	               force_dir[j][i]=3;
	            }
	            else //random dipole direction
	            {
	               force_dir[j][i]=rand()%4+1;
	            }
			}
	    }
	}
	
//*********************************************************************************************************
//                         Applying load on the nodes base on the cell orientation
//*********************************************************************************************************		
	int node_1, node_2; //cell points applying forces
	for (j = 0; j < N; j++)
	{
		for (i = 0; i < N; i++)
		{
			if (force_dir[j][i] == 1) //Lateral dipole 0°
			{
				node_1 = i + 1 + j * N - 1;
				node_2 = i + 1 + j * N + 1;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 1 << ", " << F_FIBRO << endl;
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 1 << ", " << -F_FIBRO << endl;
				myfile << "**" << endl;
			}
			else if (force_dir[j][i] == 2) //Diagonal right dipole 45°
			{
				node_1 = i + 1 + j * N - (N + 1);
				node_2 = i + 1 + j * N + (N + 1);

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 1 << ", " << F_FIBROcos << endl;   // (cos45°*F_FIBRO)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 2 << ", " << F_FIBROcos << endl;  // (sin45°*F_FIBRO)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 1 << ", " << -F_FIBROcos << endl;   //(cos45°*F_FIBRO)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 2 << ", " << -F_FIBROcos << endl;  // (sin45°*F_FIBRO)
				myfile << "**" << endl;
			}
			else if (force_dir[j][i] == 3) //Axial dipole 90°
			{
				node_1 = i + 1 + j * N - N;
				node_2 = i + 1 + j * N + N;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 2 << ", " << F_FIBRO << endl;
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 2 << ", " << -F_FIBRO << endl;
				myfile << "**" << endl;
			}
			else if (force_dir[j][i] == 4) //Diagonal left dipole 135°(-45°)
			{
				node_1 = i + 1 + j * N - (N - 1);
				node_2 = i + 1 + j * N + (N - 1);

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 1 << ", " << -F_FIBROcos << endl;   // (cos45°*F_FIBRO)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 2 << ", " << F_FIBROcos << endl;  // (sin45°*F_FIBRO)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 1 << ", " << F_FIBROcos << endl;   //(cos45°*F_FIBRO)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 2 << ", " << -F_FIBROcos << endl;  // (sin45°*F_FIBRO)
				myfile << "**" << endl;
			}
		} // End for i
	} // End for j


//*********************************************************************************************************
//                         Applying forces at the sprout tip (tip cell behaves like a dipole)
//*********************************************************************************************************		
	vessel = 0;
	i = 0;
	j = 0;
	int node_v1, node_v2, node_v3, node_v4, node_v5, node_v6, node_v7, node_v8;

	//		  
	//
	//		  6  |  7  | 8
	//      ----------------
	//		  5 | tip | 1
	//	    ----------------
	//		  4 |  3  | 2
	//


	for (vessel = 0; vessel < number_vessels_init; vessel++) //for each vessel
	{
		j = tip_vessel_x[vessel]; //select the tip node 
		i = tip_vessel_y[vessel];
		if (i == 0 || i == N-1) // force just up/down 
		{
			node_v3 = i + 1 + j * N - N; //down
			node_v7 = i + 1 + j * N + N; // up

			myfile << "*Cload" << endl; //down
			myfile << node_v3 << ", " << 2 << ", " << F_ENDO << endl; 
			myfile << "**" << endl;

			myfile << "*Cload" << endl; // up
			myfile << node_v7 << ", " << 2 << ", " << -F_ENDO << endl;
			myfile << "**" << endl;
		}
		else // along the direction of growth
		{
			switch (previous_dir[vessel])
			{
				case 1:
					node_v1 = i + 1 + j * N + 1; // right 
					node_v5 = i + 1 + j * N - 1; // left
					
					myfile << "*Cload" << endl; // right
					myfile << node_v1 << ", " << 1 << ", " << -F_ENDO << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // left
					myfile << node_v5 << ", " << 1 << ", " << F_ENDO << endl;
					myfile << "**" << endl;
				break;
				
				case 2:
					node_v2 = i + 1 + j * N - (N - 1);// bottom-right
					node_v6 = i + 1 + j * N + (N - 1); // top-left

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 1 << ", " << -F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 2 << ", " << F_ENDOcos << endl;  
					myfile << "**" << endl;		
					
					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 1 << ", " << F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 2 << ", " << -F_ENDOcos << endl;  
					myfile << "**" << endl;	
				break;
				
				case 3:
					node_v3 = i + 1 + j * N - N; //down
					node_v7 = i + 1 + j * N + N; // up
					
					myfile << "*Cload" << endl; //down
					myfile << node_v3 << ", " << 2 << ", " << F_ENDO << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // up
					myfile << node_v7 << ", " << 2 << ", " << -F_ENDO << endl;
					myfile << "**" << endl;
				break;
				
				case 4:
					node_v4 = i + 1 + j * N - (N + 1); // bottom-left
					node_v8 = i + 1 + j * N + (N + 1); // top-right
					
					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 1 << ", " << F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 2 << ", " << F_ENDOcos << endl;  
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 1 << ", " << -F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 2 << ", " << -F_ENDOcos << endl;  
					myfile << "**" << endl;
				break;
				
				case 5:
					node_v1 = i + 1 + j * N + 1; // right 
					node_v5 = i + 1 + j * N - 1; // left
					
					myfile << "*Cload" << endl; // right
					myfile << node_v1 << ", " << 1 << ", " << -F_ENDO << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // left
					myfile << node_v5 << ", " << 1 << ", " << F_ENDO << endl;
					myfile << "**" << endl;
				break;
				
				case 6:
					node_v2 = i + 1 + j * N - (N - 1);// bottom-right
					node_v6 = i + 1 + j * N + (N - 1); // top-left

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 1 << ", " << -F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 2 << ", " << F_ENDOcos << endl;  
					myfile << "**" << endl;		
					
					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 1 << ", " << F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 2 << ", " << -F_ENDOcos << endl;  
					myfile << "**" << endl;	
				break;
				
				case 7:
					node_v3 = i + 1 + j * N - N; //down
					node_v7 = i + 1 + j * N + N; // up
					
					myfile << "*Cload" << endl; //down
					myfile << node_v3 << ", " << 2 << ", " << F_ENDO << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // up
					myfile << node_v7 << ", " << 2 << ", " << -F_ENDO << endl;
					myfile << "**" << endl;
				break;
				
				case 8:
					node_v4 = i + 1 + j * N - (N + 1); // bottom-left
					node_v8 = i + 1 + j * N + (N + 1); // top-right
					
					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 1 << ", " << F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 2 << ", " << F_ENDOcos << endl;  
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 1 << ", " << -F_ENDOcos << endl;   
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 2 << ", " << -F_ENDOcos << endl; 
					myfile << "**" << endl;
				break;
			} //end switch
		}// end else
	} //end for

	ofstream file;
    file.open ("cell_number.txt"); // write number of fibroblasts
    file<<fibro_number;
    file.close();


    myfile<<"*************************************"<<endl;
    myfile<<"** OUTPUT REQUESTS"<<endl;
    myfile<<"*************************************"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Restart, write, frequency=0"<<endl;
    myfile<<"**"<<endl;
    myfile<<"** FIELD OUTPUT: F-Output-1"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Output, field, variable=PRESELECT"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Element Output, directions=YES"<<endl;
	myfile<<"EP, E"<<endl;
    myfile<<"*EL PRINT, POSITION=AVERAGED AT NODES, ELSET=ALL, frequency=99999"<<endl; 
    myfile<<"EP,E"<<endl;
    myfile<<"*NODE PRINT, NSET=ALL, frequency=99999"<<endl; 
    myfile<<"U"<<endl; 
    myfile<<"** HISTORY OUTPUT: H-Output-1"<<endl;
    myfile<<"*Output, history, variable=PRESELECT"<<endl;
    myfile<<"*End Step"<<endl;
    myfile.close();

}
