#include <cstdlib>
#include <iostream>
#include <sstream>
#include <string>
#include <fstream>
#include <math.h>
#include <vector>
#include <iomanip>
#include <algorithm>
#include <limits> // Press inter to continue

using namespace std;

const int n=251;

void Initialize_model(int cell_matrix[n][n], int vessel_x[(n-1)*20][n-1], int vessel_y[(n-1)*20][n-1], int force_dir[n][n], int nodes[(n-1)*(n-1)][4], int fibro_number, int endo_number, int& number_vessels_init, int tip_vessel_x [(n-1)*20], int tip_vessel_y [(n-1)*20], int previous_dir [(n-1)*20], int length [(n-1)*20], double X[n*n], double Y[n*n])
{
	fibro_number=0;
	endo_number=0; // counts ECs in each vessel
	number_vessels_init=0;
	// traction force
	float f_fibro = 0.000018;
	float f_fibro_cos = 0.0000127;
	float f_endo = 0.000010;
	float f_endo_cos = 0.00000707;


//*********************************************************************************************************
//                                      Initialize cell matrix
//*********************************************************************************************************
	cout<<"Initialize cell matrix"<<endl;

	int i,j;

	for (j=0;j<n;j++)
	{
	    for (i=0;i<n;i++)
	    {
	        cell_matrix[j][i]=0;
	        force_dir[j][i]=0;
	    }
	}

	j=0; //first row: cells cannot be seeded here
	for (i=0;i<n;i++)
	{
	    cell_matrix[j][i]=1;
	}

	j=n-1; //last row
	for (i=0;i<n;i++)
	{
	    cell_matrix[j][i]=1;
	}

//*********************************************************************************************************
//                     Blocking the area that cells can not migrate in
//*********************************************************************************************************

    for (j=0;j<101;j++)  // Bottom Cortical Bones
	{
	    for (i=50;i<71;i++) // Left
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }

	    for (i=180;i<201;i++) //Right
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }
	}
	
	for (j=150;j<251;j++)  // Top Cortical Bones
	{
	    for (i=50;i<71;i++) //Left
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }
	    
	    for (i=180;i<201;i++) //Right
	    {
	        cell_matrix[j][i]=1;
	        force_dir[j][i]=5;
	    }
	}

	ostringstream s;
    s<<"FEM_0.inp";

    string filename1=s.str();

    ofstream myfile;
    myfile.open(filename1.c_str(),ios::app);

// *************************************  Writing heading of the inp file ***************************************************

    myfile<<"*Heading"<<endl;
    myfile<<"** Job name: Job-1 Model name: Model-1"<<endl;
    myfile<<"** Generated by: Abaqus/CAE 6.9-2"<<endl;
    myfile<<"*Preprint, echo=NO, model=NO, history=NO, contact=NO"<<endl;
    myfile<<"**"<<endl;
    myfile<<"** PARTS"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Node, nset=node_all"<<endl;

// ***********************************************  Writing nodes **********************************************************
    int node;
	node=0;

    for (j=0;j<n;j++)
    {
        for (i=0;i<n;i++)
        {
            node=i+(j*n)+1;
            X[node]=i*0.01; // each element has a side of 0.01
            Y[node]=j*0.01;
            myfile<<node<<", "<<setprecision(15)<<X[node]<<", "<<setprecision(15)<<Y[node]<<endl;
        }
    }
	
	ifstream infile("FEM_template_mouse.txt"); // consider the txt file

    char c = infile.get();

    while  (!infile.eof())
    {
    	myfile << c;
    	c= infile.get();
    }

    cout<<"Cell matrix initialized successfully "<<endl;
    
//*********************************************************************************************************
//                                      Initialize host blood vessels
//*********************************************************************************************************   
    
    cout<<"Initialize blood vessels "<<endl;
    
    int vessel;
    int safe=80; // level until which bone marrow is not injured 
    float density_vess_bm=0.01;
	float density_vess_peri=0.1;//0.005= 0.5% as Oreilly
	int n_peri=round(density_vess_peri*safe*2);
    vessel=0; // first vessel
	int v;
    
	// initialization of vessels from periosteum: just one on ext periosteal site
	for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+48; // Bottom - left  // one of the two layers of cells composing the periosteum
		j=rand()%safe+1;
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;  
    	}
    	tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=7;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel]; //put coord x,y of first ECs
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
	}
    // Upper - left
    for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+48;
		j=rand()%safe+(n-1-safe);
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;  
    	}
    	tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=3;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
	}
	for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+201; // lower and upper right
		j=rand()%safe+1; //Lower
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;
    	}
    	tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=7;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
    }
    for (v=0;v<n_peri;v++)
	{
    	i=rand()%2+201;
    	j=rand()%safe+(n-1-safe); //Upper
		if (cell_matrix[j][i]==0)
    	{
        	cell_matrix[j][i]=2;
   		}
		tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=3;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
   		vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1;
    }
    
    //Bone Marrow region
    
    int Marrow_vess_L=0;
	int Marrow_vess_U=0;
	int v_bm=round(density_vess_bm*safe*(179-71)); //1% of bone marrow 
		
	while (Marrow_vess_L<v_bm) // (Lower bone marrow) 
   	{
        i=rand()%109+71;
        j=rand()%safe+1;// lower part seeding
        cell_matrix[j][i]=2;
   		tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=7;
    	length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];
    	vessel=vessel+1; 
		Marrow_vess_L=Marrow_vess_L+1;	
    }
    
    while (Marrow_vess_U<v_bm) // (Upper bone marrow) 
    {
        i=rand()%109+71;
        j=rand()%safe+(n-1-safe); // Upper part seeding
        cell_matrix[j][i]=2;
   		tip_vessel_x[vessel]=j; 
    	tip_vessel_y[vessel]=i; 
    	previous_dir[vessel]=3;
        length[vessel]=0;
    	vessel_x[vessel][0]=tip_vessel_x[vessel];
    	vessel_y[vessel][0]=tip_vessel_y[vessel];    		
    	vessel=vessel+1; 
		Marrow_vess_U=Marrow_vess_U+1;	
    }
    
	
	number_vessels_init=vessel;
    cout<<"Number of vessels: "<<number_vessels_init<<endl;
    cout<<endo_number<<endl;



//*********************************************************************************************************
//                                      Randomly distribute cells in the matrix
//*********************************************************************************************************
    cout<<" Distributing cells in the matrix "<<endl;

    int node_1, node_2; 
    int p=0;
	float density_fibro=0.2;
	int c_ext=round(density_fibro*safe); // 10% of periosteal external site until j=80

    // left bottom and up - ext periosteum
    
    i=49;
	
	while (p<c_ext) 
	{
		j=rand()%safe+1; //Bottom
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;  // put in the upper and lower part of periosteum numbers from 3 to the total n of cells+3
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }
    
    p=0;
	
	while (p<c_ext) 
	{
		j=rand()%safe+(n-1-safe); // Top
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }

	p = 0;

	i = 48;

	while (p < c_ext)
	{
		j = rand() % safe + 1; //Bottom
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;  // put in the upper and lower part of periosteum numbers from 3 to the total n of cells+3
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}

	p = 0;

	while (p < c_ext)
	{
		j = rand() % safe + (n-1-safe); // Top
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}
    
    // Right bottom and up - ext periosteum
    
    p=0;
    
    i=201; 
	
	while (p<c_ext)
	{
		j=rand()%safe+1; //Bottom
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }
    
    p=0;
    
	while (p<c_ext)
	{
		j=rand()%safe+(n-1-safe); //Top
	    if (cell_matrix[j][i]==0)
        {
            cell_matrix[j][i]=fibro_number+3;
            fibro_number=fibro_number+1;
            p=p+1;
        }
    }	

	p = 0;

	i = 202;

	while (p < c_ext)
	{
		j = rand() % safe + 1; //Bottom
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}

	p = 0;

	while (p < c_ext)
	{
		j = rand() % safe + (n - 1 - safe); //Top
		if (cell_matrix[j][i] == 0)
		{
			cell_matrix[j][i] = fibro_number + 3;
			fibro_number = fibro_number + 1;
			p = p + 1;
		}
	}
    
    // BONE MARROW
	
	int Marrow_cell_L=0;
	int Marrow_cell_U=0;
	int c_bm=round(density_fibro*safe*(179-71)); //10% of bone marrow until level of disruption
	
	while (Marrow_cell_L<c_bm) // (Lower bone marrow) 
							   
    {
        i=rand()%109+71;
        j=rand()%safe+1;
		if (cell_matrix[j][i]==0)
	    {
	        cell_matrix[j][i]=fibro_number+3;
	        fibro_number=fibro_number+1;
	        Marrow_cell_L=Marrow_cell_L+1;
	    }
    }
    
    while (Marrow_cell_U<c_bm) // (Upper bone marrow)
    {
        i=rand()%109+71;
        j=rand()%safe+(n-1-safe);
		if (cell_matrix[j][i]==0)
	    {
	        cell_matrix[j][i]=fibro_number+3;
	        fibro_number=fibro_number+1;
	        Marrow_cell_U=Marrow_cell_U+1;
	    }
    }	
    


//*********************************************************************************************************
//                                       Dipole direction assignment
//*********************************************************************************************************    
    
	for (j=0;j<n;j++)
	{
	    for (i=0;i<n;i++)
	    {
            if (cell_matrix[j][i]>2) // if there is a fibroblast
            {			
				if (i==0 || i==n-1) //axial dipole at edges of unclamped boundaries
	            {
	               force_dir[j][i]=3;
	            }
	            else //random dipole direction
	            {
	               force_dir[j][i]=rand()%4+1;
	            }
			}
	    }
	}
	
//*********************************************************************************************************
//                         Applying load on the nodes base on the cell orientation
//*********************************************************************************************************		
	
	for (j = 0; j < n; j++)
	{
		for (i = 0; i < n; i++)
		{
			if (force_dir[j][i] == 1) //Lateral dipole 0°
			{
				node_1 = i + 1 + j * n - 1;
				node_2 = i + 1 + j * n + 1;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 1 << ", " << f_fibro << endl;
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 1 << ", " << -f_fibro << endl;
				myfile << "**" << endl;
			}
			else if (force_dir[j][i] == 2) //Diagonal right dipole 45°
			{
				node_1 = i + 1 + j * n - (n + 1);
				node_2 = i + 1 + j * n + (n + 1);

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 1 << ", " << f_fibro_cos << endl;   // (cos45°*f_fibro)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 2 << ", " << f_fibro_cos << endl;  // (sin45°*f_fibro)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 1 << ", " << -f_fibro_cos << endl;   //(cos45°*f_fibro)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 2 << ", " << -f_fibro_cos << endl;  // (sin45°*f_fibro)
				myfile << "**" << endl;
			}
			else if (force_dir[j][i] == 3) //Axial dipole 90°
			{
				node_1 = i + 1 + j * n - n;
				node_2 = i + 1 + j * n + n;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 2 << ", " << f_fibro << endl;
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 2 << ", " << -f_fibro << endl;
				myfile << "**" << endl;
			}
			else if (force_dir[j][i] == 4) //Diagonal left dipole 135°(45°)
			{
				node_1 = i + 1 + j * n - (n - 1);
				node_2 = i + 1 + j * n + (n - 1);

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 1 << ", " << -f_fibro_cos << endl;   // (cos45°*f_fibro)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_1 << ", " << 2 << ", " << f_fibro_cos << endl;  // (sin45°*f_fibro)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 1 << ", " << f_fibro_cos << endl;   //(cos45°*f_fibro)
				myfile << "**" << endl;

				myfile << "*Cload" << endl;
				myfile << node_2 << ", " << 2 << ", " << -f_fibro_cos << endl;  // (sin45°*f_fibro)
				myfile << "**" << endl;
			}
		} // End for i
	} // End for j


//*********************************************************************************************************
//                         Applying forces on the nodes around tip cell towards the tip cell
//*********************************************************************************************************		
	vessel = 0;
	i = 0;
	j = 0;
	int node_v1, node_v2, node_v3, node_v4, node_v5, node_v6, node_v7, node_v8;

	//		  Nodes towards which tip cell apply traction force
	//
	//		  6  |  7  | 8
	//      ----------------
	//		  5 | tip | 1
	//	    ----------------
	//		  4 |  3  | 2
	//


	for (vessel = 0; vessel < number_vessels_init; vessel++)
	{
		j = tip_vessel_x[vessel]; //select the tip node
		i = tip_vessel_y[vessel];
		if (i == 0 || i == n-1) // force just up/down 
		{
			node_v3 = i + 1 + j * n - n; //down
			node_v7 = i + 1 + j * n + n; // up

			myfile << "*Cload" << endl; //down
			myfile << node_v3 << ", " << 2 << ", " << f_endo << endl; // 4nN in each direction (8 possible directions)
			myfile << "**" << endl;

			myfile << "*Cload" << endl; // up
			myfile << node_v7 << ", " << 2 << ", " << -f_endo << endl;
			myfile << "**" << endl;
		}
		else // in the direction of growth
		{
			switch (previous_dir[vessel])
			{
				case 1:
					node_v1 = i + 1 + j * n + 1; // right 
					node_v5 = i + 1 + j * n - 1; // left
					
					myfile << "*Cload" << endl; // right
					myfile << node_v1 << ", " << 1 << ", " << -f_endo << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // left
					myfile << node_v5 << ", " << 1 << ", " << f_endo << endl;
					myfile << "**" << endl;
				break;
				
				case 2:
					node_v2 = i + 1 + j * n - (n - 1);// bottom-right
					node_v6 = i + 1 + j * n + (n - 1); // top-left

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 1 << ", " << -f_endo_cos << endl;   // (cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 2 << ", " << f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;		
					
					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 1 << ", " << f_endo_cos << endl;   //(cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 2 << ", " << -f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;	
				break;
				
				case 3:
					node_v3 = i + 1 + j * n - n; //down
					node_v7 = i + 1 + j * n + n; // up
					
					myfile << "*Cload" << endl; //down
					myfile << node_v3 << ", " << 2 << ", " << f_endo << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // up
					myfile << node_v7 << ", " << 2 << ", " << -f_endo << endl;
					myfile << "**" << endl;
				break;
				
				case 4:
					node_v4 = i + 1 + j * n - (n + 1); // bottom-left
					node_v8 = i + 1 + j * n + (n + 1); // top-right
					
					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 1 << ", " << f_endo_cos << endl;   // (cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 2 << ", " << f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 1 << ", " << -f_endo_cos << endl;   //(cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 2 << ", " << -f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;
				break;
				
				case 5:
					node_v1 = i + 1 + j * n + 1; // right 
					node_v5 = i + 1 + j * n - 1; // left
					
					myfile << "*Cload" << endl; // right
					myfile << node_v1 << ", " << 1 << ", " << -f_endo << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // left
					myfile << node_v5 << ", " << 1 << ", " << f_endo << endl;
					myfile << "**" << endl;
				break;
				
				case 6:
					node_v2 = i + 1 + j * n - (n - 1);// bottom-right
					node_v6 = i + 1 + j * n + (n - 1); // top-left

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 1 << ", " << -f_endo_cos << endl;   // (cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // bottom-right
					myfile << node_v2 << ", " << 2 << ", " << f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;		
					
					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 1 << ", " << f_endo_cos << endl;   //(cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //top-left
					myfile << node_v6 << ", " << 2 << ", " << -f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;	
				break;
				
				case 7:
					node_v3 = i + 1 + j * n - n; //down
					node_v7 = i + 1 + j * n + n; // up
					
					myfile << "*Cload" << endl; //down
					myfile << node_v3 << ", " << 2 << ", " << f_endo << endl;
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // up
					myfile << node_v7 << ", " << 2 << ", " << -f_endo << endl;
					myfile << "**" << endl;
				break;
				
				case 8:
					node_v4 = i + 1 + j * n - (n + 1); // bottom-left
					node_v8 = i + 1 + j * n + (n + 1); // top-right
					
					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 1 << ", " << f_endo_cos << endl;   // (cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; //bottom-left
					myfile << node_v4 << ", " << 2 << ", " << f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 1 << ", " << -f_endo_cos << endl;   //(cos45°*0.000000004)
					myfile << "**" << endl;

					myfile << "*Cload" << endl; // top-right
					myfile << node_v8 << ", " << 2 << ", " << -f_endo_cos << endl;  // (sin45°*0.000000004)
					myfile << "**" << endl;
				break;
			} //end switch
		}// end else
	} //end for

	ofstream file;
    file.open ("cell_number.txt"); 
    file<<fibro_number;
    file.close();


    myfile<<"*************************************"<<endl;
    myfile<<"** OUTPUT REQUESTS"<<endl;
    myfile<<"*************************************"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Restart, write, frequency=0"<<endl;
    myfile<<"**"<<endl;
    myfile<<"** FIELD OUTPUT: F-Output-1"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Output, field, variable=PRESELECT"<<endl;
    myfile<<"**"<<endl;
    myfile<<"*Element Output, directions=YES"<<endl;
	myfile<<"EP, E"<<endl;
    myfile<<"*EL PRINT, POSITION=AVERAGED AT NODES, ELSET=ALL, frequency=99999"<<endl; //before: ELSET=ALL
    myfile<<"EP,E"<<endl;
    myfile<<"*NODE PRINT, NSET=ALL, frequency=99999"<<endl; // before: NSET=ALL
    myfile<<"U,RF"<<endl; 
    myfile<<"** HISTORY OUTPUT: H-Output-1"<<endl;
    myfile<<"*Output, history, variable=PRESELECT"<<endl;
    myfile<<"*End Step"<<endl;
    myfile.close();

}
